<<<<<<< HEAD

# 通信面经

1.什么是交织

在陆地移动通信这种变参信道上，**比特差错经常是成串发生的**。这是由于持续较长的深衰落谷点会影响到相继一串的比特。**然而，信道编码仅在检测和校正单个差错和不太长的差错串时才有效。**
　为了解决这一问题，**希望能找到把一条消息中的相继比特分散开的方法，即一条消息中的相继比特以非相继方式被发送。这样，在传输过程中即使发生了成串差错，恢复成一条相继比特串的消息时，差错也就变成单个(或长度很短)**，这时再用信道编码纠错功能纠正差错，恢复原消息。这种方法就是交织技术。



## 手撕代码

### 华为OD

#### 手撕代码：13个人循环报数1，2，3，3，数到3的人退出，求最后的人

\```

```C++
#include<iostream>
using namespace std
```

#### 三数之和

3.C++实现简单的字符串类，实现构造函数、析构函数、复制构造函数、重载=操作符

参考[(74条消息) 编写一个String类（c++实现）_试建立一个类string,实现将两个成员数组(str1和str2)中的字符串连接成一个字_kylee1512的博客-CSDN博客](https://blog.csdn.net/qq_40821469/article/details/108913326)

4. 求岛屿数量

## 常见问题

### TCP/UDP 计算机网络相关

相关参考：[你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？看完图解就不愁了 (qq.com)](https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA)

[4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86)

#### Tcp建立连接后，如果没有收到服务端的消息，客户端会做什么

#### 建立TCP连接有几种状态

#### TCP和UDP的区别和应用场景

TCP/UDP的区别/tcp和udp的最主要的区别是什么

OSI七层和TCP/IP四层模型的区别

### C++/语言相关

1. 多态如何实现

2.C和C++的区别

3.多态如何实现

4.一个类有几个虚函数表

5.一个父类指针指向子类对象，虚函数代码上会发生什么

6.指针和引用的区别

7.   讲讲函数指针  

8. malloc和new的底层构造有什么区别  

9.new和malloc的联系  

10. 讲讲拷贝构造函数 

 11. 深拷贝和浅拷贝的区别

12 野指针和空指针的区别，空指针有自己的地址么

13.C语言中，const和 static 的区别，char * const 和 const * char的区别

14.在平时写C++代码的过程中，遇到过哪些坑，又是如何去解决的

15. C++ 内存模型
    
    [第5篇:C/C++ 内存布局与程序栈 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/184957568)
    
    C++程序在执行时，将内存大方向划分为**4个区域**
    
    - 代码区：存放函数体的二进制代码，由操作系统进行管理的
      
      存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
    
    - 全局区：存放全局变量和静态变量以及常量
      
      (全局/静态存储区 （.bss段和.data段） 
      全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。)
    
    - 栈区stack：由编译器自动分配释放, 存放函数的参数值,局部变量等
      
      是那些编译器在需要时分配，在不需要时自动清除的存储区。存放 **局部变量、函数参数。**  
      存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
    
    - 堆区heap：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”
      
      
      
      
      
      

16. 函数重载
    
    **函数重载满足条件：**
    
    - 同一个作用域下//函数重载需要函数都在同一个作用域下
    - 函数名称相同
    - 函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**
    
    **注意:** 函数的返回值不可以作为函数重载的条件
    
    

17. C++面向对象三大特性：封装、继承和多态
    
    1).封装：
    
    封装是C++面向对象三大特性之一
    
    封装的意义：
    
    - 将属性和行为作为一个整体，表现生活中的事物
    - 将属性和行为加以权限控制
    
    **封装意义二：**
    
    类在设计时，可以把属性和行为放在不同的权限下，加以控制
    
    访问权限有三种：
    
    1. public 公共权限
    2. protected 保护权限
    3. private 私有权限
    
    //公共权限  public     类内可以访问  类外可以访问
    //保护权限  protected  类内可以访问  类外不可以访问
    //私有权限  private    类内可以访问  类外不可以访问
    
    
    
    struct和class区别
    
    在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**
    
    区别：
    
    - struct 默认权限为公共
    - class 默认权限为私有

18. 构造函数和析构函数

19. 

### 数据结构相关

#### 1.了解的数据结构

#### 2. 数组和哈希表、链表的区别
##### * 数组：
数组将元素在内存中连续存放，存储区间连续。
优缺点：
1.数组需事先定义固定的长度，不能适应数据动态增减的情况：当数据增加时，可能出现原先定义的元素个数；当数据减少时，造成内存浪费。
2.数组从栈中分配空间，可以直接通过下标迅速访问数组中的元素
3.当进行增加或删除元素时，需要移动大量的元素。

##### * 链表 
链表的存储区间离散，占用内存比较宽松。通过存在元素的指针联系到一起。
优缺点：
1.链表动态地进行存储分配，可以适应数据动态增减的情况。链表从堆中分配空间，自由度大但是申请管理比较麻烦。
2.但进行数据查询时，链表需要从第一个元素开始一直找到需要的元素位置。
3.对元素进行增删的时候，只需要改动元素的指针即可

##### * 哈希表
哈希表可以是数组和链表的结合体.
哈希冲突: 哈希表的tablesize < 数据的datasize (也不一定是这种情况哈,应该还是看咋映射的), 可能会出现两个数据查询到同一index(key)的冲突.
优缺点:
1.既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势。
2.不相同的数据通过hash函数得到相同的key值。这时候，就产生了hash冲突。解决hash冲突的方式有两种。一种是挂链式，也叫拉链法。挂链式的思想在产生冲突的hash地址指向一个链表，将具有相同的key值的数据存放到链表中。另一种是建立一个公共溢出区。将所有产生冲突的数据都存放到公共溢出区，也可以使问题解决。


##### 3. 二叉树
二叉树的存储方式: 既可以用链式存储(指针), 也可以用顺序存储(数组).
链式存储:
![[figure/Pasted image 20230901161716.png]]

顺序存储:
![[figure/Pasted image 20230901161730.png]]
**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**
但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

二叉树的遍历方式:
主要分为两种:
1.深度优先遍历: 先往深走,遇到叶子节点 (自己下面不再连接有节点的节点,也称为终端节点,度为0) 再往回走;
常见的深度优先遍历: 前序遍历(中左右)/中序遍历(左中右)/后序遍历(左右中)
![[figure/Pasted image 20230901162437.png]]
2.广度优先遍历: 一层一层的去遍历
常见的广度优先遍历: 层次遍历

```C++
#inculude <iostream>
struct TreeNode{
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int x) : val(x), left(NULL), right(NULL){}
};

```

完全二叉树
在完全二叉树中，除了最底层节点可能没有填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
![[figure/Pasted image 20230901154824.png]]



## 各类排序算法

## 快速排序 和 归并排序 

快速排序：时间复杂度 O(nlgn)， 最坏运行情况O(n^2).
```C++
#include <bits/stdc++.h>
快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
```
使用 分治 法 策略 把一个串行算法 分为 两个 子串行。
(本质上 算是 在 冒泡排序的 基础 上 的 递归分治法)

算法步骤：
1. 从数列中挑出一个元素，称为 "基准"（pivot）;
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

归并排序：
## 操作系统相关

  - [ ] 讲一讲进程和线程  
  - [ ] 进程间通信的方法  
  - [ ] 进程同步的方法，事件用过么？具体实现讲一讲  
  - [ ] 讲讲进线程生命周期  
  - [ ] 讲讲变量的生命周期怎么对应  
  - [ ] 静态变量、局部变量和全部变量的存储位置

并发和并行的概念


Linux 网络编程相关

1.Linux网络编程怎么实现

2.linux命令怎么过滤文件里面的关键字？

3.什么是死锁以及死锁产生的必要条件，如何避免死锁


=======

# 通信面经

1.什么是交织

在陆地移动通信这种变参信道上，**比特差错经常是成串发生的**。这是由于持续较长的深衰落谷点会影响到相继一串的比特。**然而，信道编码仅在检测和校正单个差错和不太长的差错串时才有效。**
　为了解决这一问题，**希望能找到把一条消息中的相继比特分散开的方法，即一条消息中的相继比特以非相继方式被发送。这样，在传输过程中即使发生了成串差错，恢复成一条相继比特串的消息时，差错也就变成单个(或长度很短)**，这时再用信道编码纠错功能纠正差错，恢复原消息。这种方法就是交织技术。

## 手撕代码

### 华为OD

#### 手撕代码：13个人循环报数1，2，3，3，数到3的人退出，求最后的人

\```

```C++
#include<iostream>

using namespace std
```

#### 三数之和

3.C++实现简单的字符串类，实现构造函数、析构函数、复制构造函数、重载=操作符

参考[(74条消息) 编写一个String类（c++实现）_试建立一个类string,实现将两个成员数组(str1和str2)中的字符串连接成一个字_kylee1512的博客-CSDN博客](https://blog.csdn.net/qq_40821469/article/details/108913326)

4. 求岛屿数量

## 常见问题

### TCP/UDP 计算机网络相关

#### Tcp建立连接后，如果没有收到服务端的消息，客户端会做什么

#### 建立TCP连接有几种状态

#### TCP和UDP的区别和应用场景

TCP/UDP的区别/tcp和udp的最主要的区别是什么

OSI七层和TCP/IP四层模型的区别

### C++/语言相关

1. 多态如何实现

2.C和C++的区别

3.多态如何实现

4.一个类有几个虚函数表

5.一个父类指针指向子类对象，虚函数代码上会发生什么

6.指针和引用的区别

7.   讲讲函数指针  

8. malloc和new的底层构造有什么区别  

9.new和malloc的联系  

10. 讲讲拷贝构造函数 

 11. 深拷贝和浅拷贝的区别

12 野指针和空指针的区别，空指针有自己的地址么

13.C语言中，const和 static 的区别，char * const 和 const * char的区别

14.在平时写C++代码的过程中，遇到过哪些坑，又是如何去解决的

15. C++ 内存模型
    
    [第5篇:C/C++ 内存布局与程序栈 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/184957568)
    
    C++程序在执行时，将内存大方向划分为**4个区域**
    
    - 代码区：存放函数体的二进制代码，由操作系统进行管理的
      
      存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
    
    - 全局区：存放全局变量和静态变量以及常量
      
      (全局/静态存储区 （.bss段和.data段） 
      全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。)
    
    - 栈区stack：由编译器自动分配释放, 存放函数的参数值,局部变量等
      
      是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。  
      存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

    - 堆区heap：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收
    
      由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”


### 操作系统相关

  - [ ] 讲一讲进程和线程  
  - [ ] 进程间通信的方法  
  - [ ] 进程同步的方法，事件用过么？具体实现讲一讲  
  - [ ] 讲讲进线程生命周期  
  - [ ] 讲讲变量的生命周期怎么对应  
  - [ ] 静态变量、局部变量和全部变量的存储位置

并发和并行的概念

Linux网络编程怎么实现

linux命令怎么过滤文件里面的关键字？

什么是死锁以及死锁产生的必要条件，如何避免死锁

Linux 网络编程相关

> > > > > > > 
