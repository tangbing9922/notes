
### 三大特性：封装、继承、多态

## 0828
### 何为构造函数？干嘛的

在C++中，当我们创建了一个自定义类对象时，编译器首先要为我们分配一块内存，用来存储这个对象。

这一点，我们都很清楚。

但事实上，每当我们创建一个自定义类对象时，编译器除了第一步给我们分配一块内存外，紧跟着就要执行该类中的一个成员函数，这个特殊的成员函数就叫做构造函数。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号 ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
## 0829
### C++11 新增特性


## 0830
### C++ 内存模型

C++程序在执行时，将内存大方向分为 *4* 个区域：
+ 代码区： 存放函数体的二进制代码，由操作系统进行管理.
+ 全局区：存放全局变量和 静态变量 以及 常量 (字符串常量和const修饰的全局变量(const修饰的局部变量不在))。
+ 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
+ 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。
其中代码区和全局区是程序运行前就有的(在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域：代码区和全局区)，栈区和堆区是程序运行之后才有的。

何为局部变量：写在函数体内的变量即为局部变量(哪怕是在main函数中)
由于局部变量存放在栈区，数据在函数执行完之后自动释放，因此 不要 将 某个局部变量的地址 作为函数返回值

堆区数据主要利用new关键字进行开辟内存，用new开辟的内存返回的是该内存数据类型的地址，因此要用一个指针去接收地址。

### 深拷贝 浅拷贝

浅拷贝就比如像引用类型，而深拷贝就比如值类型。
浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同）。对其中任何一个对象的改动都会影响另外一个对象。举个例子，一个人一开始叫张三，后来改名叫李四了，可是还是同一个人，不管是张三缺胳膊少腿还是李四缺胳膊少腿，都是这个人倒霉。
深拷贝是指 源对象与拷贝对象互相独立 ，其中任何一个对象的改动都不会对另外一个对象造成影响。举个例子，一个人名叫张三，后来用他克隆（假设法律允许）了另外一个人，叫李四，不管是张三缺胳膊少腿还是李四缺胳膊少腿都不会影响另外一个人。比较典型的就是Value（值）对象，如预定义类型Int32，Double，以及结构（struct），枚举（Enum）等。

浅拷贝就是对象的数据成员之间的简单赋值， 如你设计了一个没有类而没有提供它的复制(拷贝)构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝(默认的拷贝构造函数)

深拷贝就是当拷贝对象中有对其他资源（如堆、文件、系统等）的引用时（引用可以是指针或引用）时，对象的另开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。

所以 一般对于堆上的内存(用到new) 才需要深拷贝！即也需要开辟新的堆上资源。



## 0905
### 虚继承

C++中有时候会出现多继承的情况，即一个派生类同时继承自多个基类的情况，可能会引发父类中有同名成员出现，这时候需要加作用域(父类名)区分。

多继承中一种特殊情况：菱形继承：两个派生类继承同一个基类，又有某个类同时继承这两个派生类，这种继承称为菱形继承。
![[figure/Pasted image 20230905173526.png]]

菱形继承存在的问题：
1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
    
2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。

这时就需要虚继承
```C++
class Animal
{
public:
	int m_Age;
};
//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
class Sheep : virtual public Animal {};
class Tuo   : virtual public Animal {};
class SheepTuo : public Sheep, public Tuo {};
```

### 多态

多态即 使接口能够重用，增强程序的可扩展性。

静态多态:函数重载！！(划重点， 重载也是多态的一种体现！)和运算符重载 属于静态多态，复用函数名。
动态多态: 派生类和虚函数实现运行时多态。

静态多态 和 动态多态 区别:
* 静态多态的函数地址 早绑定 -编译阶段确定函数地址
* 动态多态的函数地址 晚绑定 -运行阶段确定函数地址

动态多态的满足条件：
//1、有继承关系
//2、子类重写父类中的虚函数

多态使用条件：
* 父类指针或引用指向子类对象

重写：函数返回值类型 函数名 参数列表 完全一致称为重写

### 一些面试题

[C++——来讲讲虚函数、虚继承、多态和虚函数表 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/136478734)

#### 何为虚函数？以及为什么构造函数不能是虚的 虚继承和虚函数有何区别

虚函数 是指：在类的定义中，以virtual 开头的函数就是虚函数。它的出现1、是为了便于继承的时候可以直接重写该函数，实现多态；2、是为了实现动态的编译绑定，具体实现什么功能要根据基类指针指向的对象来进行动态绑定。如果有多个子类继承自一个基类，那么我们只要继承这个基类再重写虚函数即可完成多态。

**虚函数表实现原理**
虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。


利用虚函数实现多态多态：“**当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数由指针指向的实际类型决定**”

纯虚函数：纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:

纯虚函数引入的原因：
1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
**纯虚函数最显著的特征是**：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。
定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。



#### Auto函数

#### 重写(Override) 和 重载(Overload)

* 重写 是 父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有**相同的** 名称和参数 就说该方法被  **重写**！
  子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类 中的定义如同被”屏蔽“。
  
* 重载 是 在 一个类中 多态性的一种表现。即，如果在一个类中定义了多个同名的方法，它们的参数列表不同！


区别： 重载实现于一个类中；重写实现于子类中。

重载：指的是一个类中不同的函数使用相同的函数名，但是函数的参数个数或类型不同。可以有不同的返回类型；可以有不同的访问修饰符，可以抛出不同的异常。 调用的时候根据函数的参数来区别不同的函数。
重载的特征：
1. 相同的范围(在同一个类中)；
2. 函数名字相同；
3. 参数不同；
4. virtual关键字可有可无；


重写(override 覆盖)：子类对父类函数的重新实现， 函数名和参数列表都需要与父类一样，与父类的函数体内容不一样。子类返回的类型必须与父类保持一致，子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）。
重写 (派生类函数覆盖基类函数) 的特征：
1. 不同的范围(分别位于派生类与基类)；
2. 函数名字相同；
3. 参数相同；
4. 基类函数必须带有virtual关键字；


## 0906

### C++中函数参数中\*和&的区别

#### 指针传递 swap(int \*a, int \*b)
我们在函数定义和函数声明时使用 *来修饰形参，表示这个变量是指针类型；在进行函数调用时，使用 & 来修饰实参，表示是将该变量的地址作为参数传入函数。

```c++

void swap(int *a, int *b){
	cout << "形参指针a的地址 = " << a << endl;
	cout << "形参指针b的地址 = " << b << endl;
	int tmp = *a; // *a表示a指针的value(指向的)
	*a = *b;
	*b = tmp;
}

int main(){
	int a = 5;
	int b = 10;
	
	cout<<"实参变量a的地址 = "<< &a <<endl;// 四个地址没变
	cout<<"实参变量b的地址 = "<< &b <<endl;
	cout<<"实参变量a的值 = "<< a <<endl;//5
	cout<<"实参变量b的值 = "<< b <<endl;//10
	//调用函数，指针传递方式
	swap(&a, &b); //因为swap两个形参是指针，所以传入的是实参的地址，&a表取变量a的地址
	cout<<"实参变量a的值 = "<< a <<endl;//10
	cout<<"实参变量b的值 = "<< b <<endl;//5
	//将实参变量的地址传递给形参，通过形参指针更改实参指向的内存空间的值
	getchar();
	return 0;
}
```

#### 引用传递 Fun(int &a)

 引用传递方式
1. 引用实际上是某一个变量的别名，和这个变量具有相同的内存空间。 
2. 实参把变量传递给形参引用，相当于形参是实参变量的别名，对形参的修改都是直接修改实参。
3. 在类的成员函数中经常用到类的引用对象作为形参，大大的提高代码的效率。
引用传递在函数调用时，直接给变量就行，和值传递一样，不需要任何修饰符。



#### C/C++程序运行过程

编写完成一个C/C++程序后，想要运行起来，必须要经过四个步骤：预处理、编译、汇编和链接。每个步骤都会生成对应的文件，如下图所示（注意后缀名）：
![[figure/Pasted image 20230906154020.png]]


## 0909
### Git常见面试题
[GIT | GIT常见面试题_面试git问题_Starry-的博客-CSDN博客](https://blog.csdn.net/nobody_1/article/details/88956315)


### C++ 内存泄漏

### GDB程序调试


### 普通局部变量与static局部变量的区别

#### 何为static静态变量

内存分配和释放
1、普通局部变量只有执行到变量定义的语句的时候才分配空间。
2、static局部变量在编译阶段（函数还没有执行），变量的空间已经分配。
3、普通局部变量离开作用域{}，自动释放其空间，也就无法使用此变量。
4、static局部变量只有在整个程序结束的时候才将其自动释放。

初始化
1、普通局部变量不初始化，为随机值。
2、static局部变量不初始化，为0。
3、static局部变量初始化语句只有第一次执行时有效，但是可以赋值多次。
4、static局部变量只能用它常量初始化。

### STL有哪些部分
STL广义上可以分为：容器(contained)、算法(algorithm)、迭代器(iterator)

STL可以分为六大组件：
1. 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
2. 算法：各种常用的算法，如sort、find、copy、for_each等
3. 迭代器：扮演了容器与算法之间的胶合剂。
4. 仿函数：行为类似函数，可作为算法的某种策略。
5. 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
6. 空间配置器：负责空间的配置与管理。

#### STL容器
STL可参考的链接：[C++ STL vector容器详解 (biancheng.net)](http://c.biancheng.net/view/6749.html)
简单的理解容器，它就是一些模板类的集合，和普通模板类不同的是，容器中封装的是组织数据的方法，即数据结构。
STL提供三类标准容器：序列容器、排序容器和哈希容器。排序容器和哈希容器有时也统称为关联容器。
![[figure/Pasted image 20230909163212.png]]

#### STL算法
**算法：**问题之解法也

有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)

算法分为:**质变算法**和**非质变算法**。

质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等

非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等

#### 迭代器
**迭代器：容器和算法之间粘合剂

提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

每个容器都有自己专属的迭代器

迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针
常用的容器中迭代器种类为双向迭代器，和随机访问迭代器


### 内存分配器原理


#### 参考面试问题
![[figure/Pasted image 20230909144237.png]]
a. 三大特性：封装、继承和多态



## 0911

### 常见题目

1. 多态如何实现

*1.函数和运算符重载 2. 虚函数

多态分为编译时多态和运行时多态。
编译时多态就是函数重载来实现的。
运行时多态是用虚函数来实现。
主要是子类重写父类的虚函数，使用父类引用或者父类指针来调用。
对象首地址是有一个指向虚函数表的指针的。
虚函数表存储虚函数的地址。
汇编的时候直接调用虚函数表中对应的函数。


2.C和C++的区别

3.多态如何实现

通过派生类重写基类中的虚函数实现，父类指针或引用指向子类对象。

4.一个类有几个虚函数表
要看是单继承(派生类中也仅有一个虚函数表)还是多继承(派生类中有多个虚函数表)
 参考链接：[理解C++虚函数机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/470639390)
如果是
1).单继承无虚函数覆盖(重写)：
单继承时，子类中只有一个虚函数表，父类虚函数在前，子类虚函数在后，按照声明顺序存放。
2).单继承有虚函数覆盖：
子类中有一个虚函数表，覆盖的虚函数放在虚函数表中继承于父类的位置，新增的虚函数放在继承的父类虚表的后面。
3).多继承无虚函数重写：

**子类中的虚函数要和父类的完全一样（包括限定符）才可以真正的实现多态，不然就会是重载。**

**如果重载的话，在用父类的指针指向子类的实例时会发生类型转换，结果还是调用了父类的函数。**

5.一个父类指针指向子类对象，虚函数代码上会发生什么

6.指针和引用的区别

7.   讲讲函数指针  

8. malloc和new的底层构造有什么区别  

9.new和malloc的联系  

10. 讲讲拷贝构造函数 

11. 深拷贝和浅拷贝的区别

12 野指针和空指针的区别，空指针有自己的地址么

13.C语言中，const和 static 的区别，char * const 和 const * char的区别

14.在平时写C++代码的过程中，遇到过哪些坑，又是如何去解决的

15. C++ 内存模型
    
    [第5篇:C/C++ 内存布局与程序栈 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/184957568)
    
    C++程序在执行时，将内存大方向划分为**4个区域**
    
    - 代码区：存放函数体的二进制代码，由操作系统进行管理的
      
      存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
    
    - 全局区：存放全局变量和静态变量以及常量
      
      (全局/静态存储区 （.bss段和.data段） 
      全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。)
    
    - 栈区stack：由编译器自动分配释放, 存放函数的参数值,局部变量等
      
      是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。  
      存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

    - 堆区heap：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收
    
      由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”



